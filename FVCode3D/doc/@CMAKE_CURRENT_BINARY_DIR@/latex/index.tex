\hypertarget{index_intro}{}\section{Introduction}\label{index_intro}
This code allows to solve the single-\/phase flow in a fractured porous medium modeled via the Darcy equation by using the Finite Volume (FV) method with a two-\/point flux approximation (T\+P\+FA). The fractures are required to be matching with the grid.~\newline
 The code is written in C++. As input, the program requires a mesh as \textquotesingle{}.fvg\textquotesingle{} format file. The output is given as \textquotesingle{}.vtu\textquotesingle{} file format, viewable by Paraview.~\newline
 \hypertarget{index_howto}{}\section{How to execute the program}\label{index_howto}
To run the program just execute~\newline

\begin{DoxyCode}
./fvcode3d.exe
\end{DoxyCode}
 By default, the parameters need are read from data.\+txt file.~\newline
 With the option \textquotesingle{}-\/f \textquotesingle{}, it is possible to specify the data file.~\newline
 Ex.~\newline

\begin{DoxyCode}
./fvcode3d.exe -f data.txt
\end{DoxyCode}
\hypertarget{index_input}{}\section{Input parameters}\label{index_input}
The program requires\+:~\newline

\begin{DoxyItemize}
\item an input mesh in \textquotesingle{}.fvg\textquotesingle{} format~\newline

\item the data file~\newline
 The file format \textquotesingle{}.fvg\textquotesingle{} consists of four parts\+:~\newline

\item list of P\+O\+I\+N\+TS, each of them described by its coordinates x, y, z;~\newline

\item list of F\+A\+C\+E\+TS, each of them described by a list of ids of P\+O\+I\+N\+TS, plus some properties if the facet represents a fracture;~\newline

\item list of C\+E\+L\+LS, each of them described by a list of ids of F\+A\+C\+E\+TS, plus some properties;~\newline

\item list of F\+R\+A\+C\+T\+U\+RE N\+E\+T\+W\+O\+R\+KS, each of them described by a list of F\+A\+C\+E\+TS that belong to the same network.~\newline
 The properties related to the facets that represent a fracture are the permeability, the porosity and the aperture.~\newline
 The properties related to the cells (porous medium) are the permeability and the porosity.
\end{DoxyItemize}

The data file consists of six sections\+:
\begin{DoxyItemize}
\item {\ttfamily mesh\+:} the input file parameters such as mesh location and filename~\newline

\item {\ttfamily output\+:} the output directory and filename~\newline

\item {\ttfamily problem\+:} parameters related to the problem, such as the problem type (steady or unsteady) or if apply or not the source/sink term~\newline

\item {\ttfamily fluid\+:} mobility and compressibility of the fluid~\newline

\item {\ttfamily bc\+:} the rotation to apply around the z axis, needed to correctly apply the boundary conditions~\newline

\item {\ttfamily solver\+:} the solver to use and some parameters such as the tolerance and the number of iterations~\newline
 
\end{DoxyItemize}\hypertarget{index_class}{}\section{Main Classes}\label{index_class}
The main classes involved are the following\+:~\newline

\begin{DoxyItemize}
\item {\itshape Data\+:} collects all the parameters used by the program that can be set through the datafile;~\newline

\item {\itshape Importer\+:} reads the input file mesh;~\newline

\item {\itshape Properties\+Map\+:} collects the properties of the fractures and porous medium;~\newline

\item {\itshape Mesh3D\+:} stores the geometrical mesh as {\itshape Point3D}, {\itshape Facet3D} and {\itshape Cell3D};~\newline

\item {\itshape Rigid\+\_\+\+Mesh\+:} converts a {\itshape Mesh3D} in a rigid format, suitable for assemble the problem;~\newline

\item {\itshape Boundary\+Conditions\+:} defines the boundary conditions to assign to the problem; B\+Cs can be Dirichlet or Neumann;~\newline

\item {\itshape Problem\+:} defines the problem to solve\+: it can be a steady problem ({\itshape Darcy\+Steady}) or a time-\/dependent problem ({\itshape Darcy\+Pseudo\+Steady}); it assembles the matrix and the right hand side;~\newline

\item {\itshape Solver\+:} solves the {\itshape Problem}; the code implements direct solvers as well as iterative solvers;~\newline

\item {\itshape Exporter\+:} exports as \textquotesingle{}.vtu\textquotesingle{} files the mesh, the properties, the solution and more.~\newline
 
\end{DoxyItemize}\hypertarget{index_es}{}\section{Example of usage}\label{index_es}
Here, we briefly describe how to use the code.~\newline
 First of all, read the necessary parameters from the datafile\+:~\newline
 
\begin{DoxyCode}
\textcolor{comment}{// we use the GetPot utility to access the datafile}
GetPot command\_line(argc,argv);
\textcolor{keyword}{const} std::string dataFileName = command\_line.follow(\textcolor{stringliteral}{"data.txt"}, 2, \textcolor{stringliteral}{"-f"}, \textcolor{stringliteral}{"--file"});
\textcolor{comment}{// Read Data from the datafile}
\hyperlink{namespaceFVCode3D_a3d19a370a98afe491a9e17a646a9c56f}{DataPtr\_Type} dataPtr(\textcolor{keyword}{new} Data(dataFileName));
\end{DoxyCode}


Then we define the Mesh3D, the Properties\+Map so that we can import the mesh\+:


\begin{DoxyCode}
\textcolor{comment}{//Define Mesh and Properties}
Mesh3D mesh;
PropertiesMap propMap(dataPtr->getMobility(), dataPtr->getCompressibility());
\textcolor{comment}{//Create Importer}
Importer * importer = 0;
importer = \textcolor{keyword}{new} ImporterForSolver(dataPtr->getMeshDir() + dataPtr->getMeshFile(), mesh, propMap);
\textcolor{comment}{//Import grid file}
importer->import(dataPtr->fractureOn());
\end{DoxyCode}


After the reading of the mesh, it is necessary to perform some operations to process the mesh\+:


\begin{DoxyCode}
\textcolor{comment}{//Compute the cells that separate each facet}
mesh.updateFacetsWithCells();
\textcolor{comment}{//Compute the neighboring cells of each cell}
mesh.updateCellsWithNeighbors();
\textcolor{comment}{//Set labels on boundary (necessary for BCs)}
importer->extractBC(dataPtr->getTheta());
\textcolor{comment}{//Compute facet ids of the fractures (creates fracture networks)}
mesh.updateFacetsWithFractures();
\end{DoxyCode}


We can now create the boundary conditions\+:


\begin{DoxyCode}
\textcolor{comment}{//Assign to the border marked as 'Left' a Dirichlet condition equal to 1}
BoundaryConditions::BorderBC leftBC (\hyperlink{namespaceFVCode3D_a604c2047b7f400e68b30a8132178c822a7fd633652b3723bb7716b9db0314a61e}{BorderLabel::Left}, 
      \hyperlink{namespaceFVCode3D_a73660061f11f1671164ce171a053f8c5a192024697bdaa4fbbb39b8961b747bce}{Dirichlet}, \hyperlink{namespaceFVCode3D_a1a9ede09c77441d292a079fbab60fb82}{fOne} );
\textcolor{comment}{//And so on...}
BoundaryConditions::BorderBC rightBC(\hyperlink{namespaceFVCode3D_a604c2047b7f400e68b30a8132178c822a27ec5db52b31c4eba9e240374723f76e}{BorderLabel::Right}, 
      \hyperlink{namespaceFVCode3D_a73660061f11f1671164ce171a053f8c5a192024697bdaa4fbbb39b8961b747bce}{Dirichlet}, \hyperlink{namespaceFVCode3D_a2e72cc81c6f214d6e057af7a02599501}{fZero} );
...

\textcolor{comment}{//We create a vector that contains all the BorderBC...}
std::vector<BoundaryConditions::BorderBC> borders;
\textcolor{comment}{//...and we insert into it the BCs previously created}
borders.push\_back( backBC );
borders.push\_back( frontBC );
...

\textcolor{comment}{//Finally we create the BoundaryConditions}
BoundaryConditions BC(borders);
\end{DoxyCode}


Then we create a Rigid\+\_\+\+Mesh 
\begin{DoxyCode}
\textcolor{comment}{//The Rigid\_Mesh requires the Mesh3D and the PropertesMap}
Rigid\_Mesh myrmesh(mesh, propMap);
\end{DoxyCode}


We can proceed by building the problem\+:


\begin{DoxyCode}
Problem<CentroidQuadrature, CentroidQuadrature> * darcy(\textcolor{keyword}{nullptr});
\textcolor{keyword}{typedef} DarcySteady<CentroidQuadrature, CentroidQuadrature> \hyperlink{main_8cpp_ab0de87680f9f2dfa547e659c7da3d1e4}{DarcyPb};
\textcolor{keyword}{typedef} DarcyPseudoSteady<CentroidQuadrature, CentroidQuadrature, SpMat, TimeScheme::BDF2> 
      \hyperlink{main_8cpp_aff54e4c6bbc30b11899898af00325b15}{PseudoDarcyPb};

\textcolor{comment}{//If the problem is steady}
\textcolor{keywordflow}{if}(dataPtr->getProblemType() == Data::ProblemType::steady)
\{
    darcy = \textcolor{keyword}{new} \hyperlink{main_8cpp_ab0de87680f9f2dfa547e659c7da3d1e4}{DarcyPb}(dataPtr->getSolverType(), myrmesh, BC, \hyperlink{namespaceFVCode3D_ae8b0f97f0774db9f0881cfc5f31d93f4}{SS}, dataPtr);
\}
\textcolor{comment}{//If the problem is unsteady}
\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dataPtr->getProblemType() == Data::ProblemType::pseudoSteady)
\{
    darcy = \textcolor{keyword}{new} \hyperlink{main_8cpp_aff54e4c6bbc30b11899898af00325b15}{PseudoDarcyPb}(dataPtr->getSolverType(), myrmesh, BC, 
      \hyperlink{namespaceFVCode3D_ae8b0f97f0774db9f0881cfc5f31d93f4}{SS}, dataPtr);
\}

\textcolor{comment}{//If the solver used is an iterative one, set tolerance and the maximum number of iterations}
\textcolor{keywordflow}{if}(dynamic\_cast<IterativeSolver*>(darcy->getSolverPtr()))
\{
    \textcolor{keyword}{dynamic\_cast<}IterativeSolver*\textcolor{keyword}{>}(darcy->getSolverPtr())->setMaxIter(dataPtr->getIterativeSolverMaxIter())
      ;
    \textcolor{keyword}{dynamic\_cast<}IterativeSolver*\textcolor{keyword}{>}(darcy->getSolverPtr())->setTolerance(dataPtr->
      getIterativeSolverTolerance());
\}
\end{DoxyCode}


Now, we can solve the problem\+:


\begin{DoxyCode}
  \textcolor{comment}{//In the case of a steady problem, we assemble and the solve the problem}
  \textcolor{keywordflow}{if}(dataPtr->getProblemType() == Data::ProblemType::steady)
  \{
      darcy->assemble();
      \textcolor{keywordflow}{if}(dataPtr->pressuresInFractures())
      \{
          FixPressureDofs<DarcyPb> fpd(dynamic\_cast<DarcyPb *>(darcy));
          fpd.apply(dataPtr->getPressuresInFractures());
      \}
      darcy->solve();
  \}
  \textcolor{comment}{//In the case of a unsteady problem, we initialize the problem and for each time step, we assemble and
       solve the}
problem
  \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dataPtr->getProblemType() == Data::ProblemType::pseudoSteady)
  \{
      \textcolor{keyword}{dynamic\_cast<}PseudoDarcyPb *\textcolor{keyword}{>}(darcy)->initialize();
      \textcolor{keywordflow}{for}(\hyperlink{namespaceFVCode3D_a40c1f5588a248569d80aa5f867080e83}{Real} t = dataPtr->getInitialTime() + dataPtr->getTimeStep() ; t <= dataPtr->getEndTime(); t+=
      dataPtr->getTimeStep())
      \{
          darcy->assemble();
          \textcolor{keywordflow}{if}(dataPtr->pressuresInFractures())
          \{
              FixPressureDofs<PseudoDarcyPb> fpd(dynamic\_cast<PseudoDarcyPb *>(darcy));
              fpd.apply(dataPtr->getPressuresInFractures());
          \}
          darcy->solve();
      \}
  \}
\end{DoxyCode}


The solution can be exported\+:


\begin{DoxyCode}
\textcolor{comment}{//Define Exporter}
ExporterVTU exporter;
\textcolor{comment}{//Export solution on matrix and on the fractures}
exporter.exportSolution(myrmesh, dataPtr->getOutputDir() + dataPtr->getOutputFile() + \textcolor{stringliteral}{"\_solution.vtu"}, 
      darcy->getSolver().getSolution());
exporter.exportSolutionOnFractures(myrmesh, dataPtr->getOutputDir() + dataPtr->getOutputFile() + \textcolor{stringliteral}{"
      \_solution\_f.vtu"}, darcy->getSolver().getSolution());
\end{DoxyCode}


Remember to delete the Problem and the Importer instance\+:


\begin{DoxyCode}
\textcolor{keyword}{delete} darcy;
\textcolor{keyword}{delete} importer;
\end{DoxyCode}
 