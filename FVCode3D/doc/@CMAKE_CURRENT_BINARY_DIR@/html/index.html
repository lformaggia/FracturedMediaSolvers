<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>FVCode3D: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-doxy.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FVCode3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">FVCode3D Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>This code allows to solve the single-phase flow in a fractured porous medium modeled via the Darcy equation by using the Finite Volume (FV) method with a two-point flux approximation (TPFA). The fractures are required to be matching with the grid.<br />
 The code is written in C++. As input, the program requires a mesh as '.fvg' format file. The output is given as '.vtu' file format, viewable by Paraview.<br />
 </p>
<h1><a class="anchor" id="howto"></a>
How to execute the program</h1>
<p>To run the program just execute<br />
</p><div class="fragment"><div class="line">./fvcode3d.exe</div></div><!-- fragment --><p> By default, the parameters need are read from data.txt file.<br />
 With the option '-f ', it is possible to specify the data file.<br />
 Ex.<br />
</p><div class="fragment"><div class="line">./fvcode3d.exe -f data.txt</div></div><!-- fragment --><h1><a class="anchor" id="input"></a>
Input parameters</h1>
<p>The program requires:<br />
</p><ul>
<li>an input mesh in '.fvg' format<br />
</li>
<li>the data file<br />
 The file format '.fvg' consists of four parts:<br />
</li>
<li>list of POINTS, each of them described by its coordinates x, y, z;<br />
</li>
<li>list of FACETS, each of them described by a list of ids of POINTS, plus some properties if the facet represents a fracture;<br />
</li>
<li>list of CELLS, each of them described by a list of ids of FACETS, plus some properties;<br />
</li>
<li>list of FRACTURE NETWORKS, each of them described by a list of FACETS that belong to the same network.<br />
 The properties related to the facets that represent a fracture are the permeability, the porosity and the aperture.<br />
 The properties related to the cells (porous medium) are the permeability and the porosity.</li>
</ul>
<p>The data file consists of six sections:</p><ul>
<li><code>mesh:</code> the input file parameters such as mesh location and filename<br />
</li>
<li><code>output:</code> the output directory and filename<br />
</li>
<li><code>problem:</code> parameters related to the problem, such as the problem type (steady or unsteady) or if apply or not the source/sink term<br />
</li>
<li><code>fluid:</code> mobility and compressibility of the fluid<br />
</li>
<li><code>bc:</code> the rotation to apply around the z axis, needed to correctly apply the boundary conditions<br />
</li>
<li><code>solver:</code> the solver to use and some parameters such as the tolerance and the number of iterations<br />
 </li>
</ul>
<h1><a class="anchor" id="class"></a>
Main Classes</h1>
<p>The main classes involved are the following:<br />
</p><ul>
<li><em>Data:</em> collects all the parameters used by the program that can be set through the datafile;<br />
</li>
<li><em>Importer:</em> reads the input file mesh;<br />
</li>
<li><em>PropertiesMap:</em> collects the properties of the fractures and porous medium;<br />
</li>
<li><em>Mesh3D:</em> stores the geometrical mesh as <em>Point3D</em>, <em>Facet3D</em> and <em>Cell3D</em>;<br />
</li>
<li><em>Rigid_Mesh:</em> converts a <em>Mesh3D</em> in a rigid format, suitable for assemble the problem;<br />
</li>
<li><em>BoundaryConditions:</em> defines the boundary conditions to assign to the problem; BCs can be Dirichlet or Neumann;<br />
</li>
<li><em>Problem:</em> defines the problem to solve: it can be a steady problem (<em>DarcySteady</em>) or a time-dependent problem (<em>DarcyPseudoSteady</em>); it assembles the matrix and the right hand side;<br />
</li>
<li><em>Solver:</em> solves the <em>Problem</em>; the code implements direct solvers as well as iterative solvers;<br />
</li>
<li><em>Exporter:</em> exports as '.vtu' files the mesh, the properties, the solution and more.<br />
 </li>
</ul>
<h1><a class="anchor" id="es"></a>
Example of usage</h1>
<p>Here, we briefly describe how to use the code.<br />
 First of all, read the necessary parameters from the datafile:<br />
 </p><div class="fragment"><div class="line"><span class="comment">// we use the GetPot utility to access the datafile</span></div><div class="line">GetPot command_line(argc,argv);</div><div class="line"><span class="keyword">const</span> std::string dataFileName = command_line.follow(<span class="stringliteral">&quot;data.txt&quot;</span>, 2, <span class="stringliteral">&quot;-f&quot;</span>, <span class="stringliteral">&quot;--file&quot;</span>);</div><div class="line"><span class="comment">// Read Data from the datafile</span></div><div class="line"><a class="code" href="namespaceFVCode3D.html#a3d19a370a98afe491a9e17a646a9c56f">DataPtr_Type</a> dataPtr(<span class="keyword">new</span> Data(dataFileName));</div></div><!-- fragment --><p>Then we define the Mesh3D, the PropertiesMap so that we can import the mesh:</p>
<div class="fragment"><div class="line"><span class="comment">//Define Mesh and Properties</span></div><div class="line">Mesh3D mesh;</div><div class="line">PropertiesMap propMap(dataPtr-&gt;getMobility(), dataPtr-&gt;getCompressibility());</div><div class="line"><span class="comment">//Create Importer</span></div><div class="line">Importer * importer = 0;</div><div class="line">importer = <span class="keyword">new</span> ImporterForSolver(dataPtr-&gt;getMeshDir() + dataPtr-&gt;getMeshFile(), mesh, propMap);</div><div class="line"><span class="comment">//Import grid file</span></div><div class="line">importer-&gt;import(dataPtr-&gt;fractureOn());</div></div><!-- fragment --><p>After the reading of the mesh, it is necessary to perform some operations to process the mesh:</p>
<div class="fragment"><div class="line"><span class="comment">//Compute the cells that separate each facet</span></div><div class="line">mesh.updateFacetsWithCells();</div><div class="line"><span class="comment">//Compute the neighboring cells of each cell</span></div><div class="line">mesh.updateCellsWithNeighbors();</div><div class="line"><span class="comment">//Set labels on boundary (necessary for BCs)</span></div><div class="line">importer-&gt;extractBC(dataPtr-&gt;getTheta());</div><div class="line"><span class="comment">//Compute facet ids of the fractures (creates fracture networks)</span></div><div class="line">mesh.updateFacetsWithFractures();</div></div><!-- fragment --><p>We can now create the boundary conditions:</p>
<div class="fragment"><div class="line"><span class="comment">//Assign to the border marked as &#39;Left&#39; a Dirichlet condition equal to 1</span></div><div class="line">BoundaryConditions::BorderBC leftBC (<a class="code" href="namespaceFVCode3D.html#a604c2047b7f400e68b30a8132178c822a7fd633652b3723bb7716b9db0314a61e">BorderLabel::Left</a>, <a class="code" href="namespaceFVCode3D.html#a73660061f11f1671164ce171a053f8c5a192024697bdaa4fbbb39b8961b747bce">Dirichlet</a>, <a class="code" href="namespaceFVCode3D.html#a1a9ede09c77441d292a079fbab60fb82">fOne</a> );</div><div class="line"><span class="comment">//And so on...</span></div><div class="line">BoundaryConditions::BorderBC rightBC(<a class="code" href="namespaceFVCode3D.html#a604c2047b7f400e68b30a8132178c822a27ec5db52b31c4eba9e240374723f76e">BorderLabel::Right</a>, <a class="code" href="namespaceFVCode3D.html#a73660061f11f1671164ce171a053f8c5a192024697bdaa4fbbb39b8961b747bce">Dirichlet</a>, <a class="code" href="namespaceFVCode3D.html#a2e72cc81c6f214d6e057af7a02599501">fZero</a> );</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">//We create a vector that contains all the BorderBC...</span></div><div class="line">std::vector&lt;BoundaryConditions::BorderBC&gt; borders;</div><div class="line"><span class="comment">//...and we insert into it the BCs previously created</span></div><div class="line">borders.push_back( backBC );</div><div class="line">borders.push_back( frontBC );</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">//Finally we create the BoundaryConditions</span></div><div class="line">BoundaryConditions BC(borders);</div></div><!-- fragment --><p>Then we create a Rigid_Mesh </p><div class="fragment"><div class="line"><span class="comment">//The Rigid_Mesh requires the Mesh3D and the PropertesMap</span></div><div class="line">Rigid_Mesh myrmesh(mesh, propMap);</div></div><!-- fragment --><p>We can proceed by building the problem:</p>
<div class="fragment"><div class="line">Problem&lt;CentroidQuadrature, CentroidQuadrature&gt; * darcy(<span class="keyword">nullptr</span>);</div><div class="line"><span class="keyword">typedef</span> DarcySteady&lt;CentroidQuadrature, CentroidQuadrature&gt; <a class="code" href="main_8cpp.html#ab0de87680f9f2dfa547e659c7da3d1e4">DarcyPb</a>;</div><div class="line"><span class="keyword">typedef</span> DarcyPseudoSteady&lt;CentroidQuadrature, CentroidQuadrature, SpMat, TimeScheme::BDF2&gt; <a class="code" href="main_8cpp.html#aff54e4c6bbc30b11899898af00325b15">PseudoDarcyPb</a>;</div><div class="line"></div><div class="line"><span class="comment">//If the problem is steady</span></div><div class="line"><span class="keywordflow">if</span>(dataPtr-&gt;getProblemType() == Data::ProblemType::steady)</div><div class="line">{</div><div class="line">    darcy = <span class="keyword">new</span> <a class="code" href="main_8cpp.html#ab0de87680f9f2dfa547e659c7da3d1e4">DarcyPb</a>(dataPtr-&gt;getSolverType(), myrmesh, BC, <a class="code" href="namespaceFVCode3D.html#ae8b0f97f0774db9f0881cfc5f31d93f4">SS</a>, dataPtr);</div><div class="line">}</div><div class="line"><span class="comment">//If the problem is unsteady</span></div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(dataPtr-&gt;getProblemType() == Data::ProblemType::pseudoSteady)</div><div class="line">{</div><div class="line">    darcy = <span class="keyword">new</span> <a class="code" href="main_8cpp.html#aff54e4c6bbc30b11899898af00325b15">PseudoDarcyPb</a>(dataPtr-&gt;getSolverType(), myrmesh, BC, <a class="code" href="namespaceFVCode3D.html#ae8b0f97f0774db9f0881cfc5f31d93f4">SS</a>, dataPtr);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//If the solver used is an iterative one, set tolerance and the maximum number of iterations</span></div><div class="line"><span class="keywordflow">if</span>(dynamic_cast&lt;IterativeSolver*&gt;(darcy-&gt;getSolverPtr()))</div><div class="line">{</div><div class="line">    <span class="keyword">dynamic_cast&lt;</span>IterativeSolver*<span class="keyword">&gt;</span>(darcy-&gt;getSolverPtr())-&gt;setMaxIter(dataPtr-&gt;getIterativeSolverMaxIter());</div><div class="line">    <span class="keyword">dynamic_cast&lt;</span>IterativeSolver*<span class="keyword">&gt;</span>(darcy-&gt;getSolverPtr())-&gt;setTolerance(dataPtr-&gt;getIterativeSolverTolerance());</div><div class="line">}</div></div><!-- fragment --><p>Now, we can solve the problem:</p>
<div class="fragment"><div class="line">  <span class="comment">//In the case of a steady problem, we assemble and the solve the problem</span></div><div class="line">  <span class="keywordflow">if</span>(dataPtr-&gt;getProblemType() == Data::ProblemType::steady)</div><div class="line">  {</div><div class="line">      darcy-&gt;assemble();</div><div class="line">      <span class="keywordflow">if</span>(dataPtr-&gt;pressuresInFractures())</div><div class="line">      {</div><div class="line">          FixPressureDofs&lt;DarcyPb&gt; fpd(dynamic_cast&lt;DarcyPb *&gt;(darcy));</div><div class="line">          fpd.apply(dataPtr-&gt;getPressuresInFractures());</div><div class="line">      }</div><div class="line">      darcy-&gt;solve();</div><div class="line">  }</div><div class="line">  <span class="comment">//In the case of a unsteady problem, we initialize the problem and for each time step, we assemble and solve the</span></div><div class="line">problem</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(dataPtr-&gt;getProblemType() == Data::ProblemType::pseudoSteady)</div><div class="line">  {</div><div class="line">      <span class="keyword">dynamic_cast&lt;</span>PseudoDarcyPb *<span class="keyword">&gt;</span>(darcy)-&gt;initialize();</div><div class="line">      <span class="keywordflow">for</span>(<a class="code" href="namespaceFVCode3D.html#a40c1f5588a248569d80aa5f867080e83">Real</a> t = dataPtr-&gt;getInitialTime() + dataPtr-&gt;getTimeStep() ; t &lt;= dataPtr-&gt;getEndTime(); t+=dataPtr-&gt;getTimeStep())</div><div class="line">      {</div><div class="line">          darcy-&gt;assemble();</div><div class="line">          <span class="keywordflow">if</span>(dataPtr-&gt;pressuresInFractures())</div><div class="line">          {</div><div class="line">              FixPressureDofs&lt;PseudoDarcyPb&gt; fpd(dynamic_cast&lt;PseudoDarcyPb *&gt;(darcy));</div><div class="line">              fpd.apply(dataPtr-&gt;getPressuresInFractures());</div><div class="line">          }</div><div class="line">          darcy-&gt;solve();</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The solution can be exported:</p>
<div class="fragment"><div class="line"><span class="comment">//Define Exporter</span></div><div class="line">ExporterVTU exporter;</div><div class="line"><span class="comment">//Export solution on matrix and on the fractures</span></div><div class="line">exporter.exportSolution(myrmesh, dataPtr-&gt;getOutputDir() + dataPtr-&gt;getOutputFile() + <span class="stringliteral">&quot;_solution.vtu&quot;</span>, darcy-&gt;getSolver().getSolution());</div><div class="line">exporter.exportSolutionOnFractures(myrmesh, dataPtr-&gt;getOutputDir() + dataPtr-&gt;getOutputFile() + <span class="stringliteral">&quot;_solution_f.vtu&quot;</span>, darcy-&gt;getSolver().getSolution());</div></div><!-- fragment --><p>Remember to delete the Problem and the Importer instance:</p>
<div class="fragment"><div class="line"><span class="keyword">delete</span> darcy;</div><div class="line"><span class="keyword">delete</span> importer;</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 17 2017 17:44:47 for FVCode3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
